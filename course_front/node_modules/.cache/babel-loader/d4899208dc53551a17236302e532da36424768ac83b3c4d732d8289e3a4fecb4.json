{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\n/**\n * We can remove this when IE not support anymore\n */\nexport var NumberDecimal = /*#__PURE__*/function () {\n  function NumberDecimal(value) {\n    _classCallCheck(this, NumberDecimal);\n    _defineProperty(this, \"origin\", '');\n    if (!value && value !== 0 || !String(value).trim()) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  _createClass(NumberDecimal, [{\n    key: \"negate\",\n    value: function negate() {\n      return new NumberDecimal(-this.toNumber());\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new NumberDecimal(value);\n      }\n      var target = Number(value);\n      if (Number.isNaN(target)) {\n        return this;\n      }\n      var number = this.number + target;\n      // [Legacy] Back to safe integer\n      if (number > Number.MAX_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n      }\n      if (number < Number.MIN_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n      }\n      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n      return new NumberDecimal(number.toFixed(maxPrecision));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return Number.isNaN(this.number);\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.number;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return num2str(this.number);\n    }\n  }]);\n  return NumberDecimal;\n}();\nexport var BigIntDecimal = /*#__PURE__*/function () {\n  function BigIntDecimal(value) {\n    _classCallCheck(this, BigIntDecimal);\n    _defineProperty(this, \"origin\", '');\n    if (!value && value !== 0 || !String(value).trim()) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-') {\n      this.nan = true;\n      return;\n    }\n    var mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      var trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      var numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      var decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  _createClass(BigIntDecimal, [{\n    key: \"getMark\",\n    value: function getMark() {\n      return this.negative ? '-' : '';\n    }\n  }, {\n    key: \"getIntegerStr\",\n    value: function getIntegerStr() {\n      return this.integer.toString();\n    }\n  }, {\n    key: \"getDecimalStr\",\n    value: function getDecimalStr() {\n      return this.decimal.toString().padStart(this.decimalLen, '0');\n    }\n    /**\n     * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n     * This is used for add function only.\n     */\n  }, {\n    key: \"alignDecimal\",\n    value: function alignDecimal(decimalLength) {\n      var str = \"\".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, '0'));\n      return BigInt(str);\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var clone = new BigIntDecimal(this.toString());\n      clone.negative = !clone.negative;\n      return clone;\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new BigIntDecimal(value);\n      }\n      var offset = new BigIntDecimal(value);\n      if (offset.isInvalidate()) {\n        return this;\n      }\n      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n      var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n      // We need fill string length back to `maxDecimalLength` to avoid parser failed\n      var _trimNumber = trimNumber(valueStr),\n        negativeStr = _trimNumber.negativeStr,\n        trimStr = _trimNumber.trimStr;\n      var hydrateValueStr = \"\".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, '0'));\n      return new BigIntDecimal(\"\".concat(hydrateValueStr.slice(0, -maxDecimalLength), \".\").concat(hydrateValueStr.slice(-maxDecimalLength)));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return this.nan;\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      if (this.isNaN()) {\n        return NaN;\n      }\n      return Number(this.toString());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return trimNumber(\"\".concat(this.getMark()).concat(this.getIntegerStr(), \".\").concat(this.getDecimalStr())).fullStr;\n    }\n  }]);\n  return BigIntDecimal;\n}();\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * round up an unsigned number str, like: 1.4 -> 2, 1.5 -> 2\n */\nexport function roundUpUnsignedDecimal(numStr, precision) {\n  var _trimNumber2 = trimNumber(numStr),\n    integerStr = _trimNumber2.integerStr,\n    decimalStr = _trimNumber2.decimalStr;\n  var advancedDecimal = getMiniDecimal(integerStr + '.' + decimalStr).add(\"0.\".concat('0'.repeat(precision), 5));\n  return toFixed(advancedDecimal.toString(), '.', precision);\n}\n/**\n * round up an unsigned number str, like: 1.4 -> 1, 1.5 -> 1\n */\nexport function roundDownUnsignedDecimal(numStr, precision) {\n  var _trimNumber3 = trimNumber(numStr),\n    negativeStr = _trimNumber3.negativeStr,\n    integerStr = _trimNumber3.integerStr,\n    decimalStr = _trimNumber3.decimalStr;\n  var numberWithoutDecimal = \"\".concat(negativeStr).concat(integerStr);\n  if (precision === 0) {\n    return integerStr;\n  }\n  return \"\".concat(numberWithoutDecimal, \".\").concat(decimalStr.padEnd(precision, '0').slice(0, precision));\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  if (numStr === '') {\n    return '';\n  }\n  var _trimNumber4 = trimNumber(numStr),\n    negativeStr = _trimNumber4.negativeStr,\n    integerStr = _trimNumber4.integerStr,\n    decimalStr = _trimNumber4.decimalStr;\n  var precisionDecimalStr = \"\".concat(separatorStr).concat(decimalStr);\n  var numberWithoutDecimal = \"\".concat(negativeStr).concat(integerStr);\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    var advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5) {\n      var advancedDecimal = getMiniDecimal(numStr).add(\"\".concat(negativeStr, \"0.\").concat('0'.repeat(precision)).concat(10 - advancedNum));\n      return toFixed(advancedDecimal.toString(), separatorStr, precision);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return \"\".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, '0').slice(0, precision));\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return \"\".concat(numberWithoutDecimal).concat(precisionDecimalStr);\n}","map":{"version":3,"names":["_classCallCheck","_createClass","_defineProperty","getNumberPrecision","isE","num2str","trimNumber","validateNumber","supportBigInt","NumberDecimal","value","String","trim","empty","origin","number","Number","key","negate","toNumber","add","isInvalidate","target","isNaN","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","maxPrecision","Math","max","toFixed","isEmpty","equals","lessEquals","toString","safe","arguments","length","undefined","BigIntDecimal","nan","mergedValue","trimRet","negative","numbers","trimStr","split","integer","BigInt","decimalStr","decimal","decimalLen","getMark","getIntegerStr","getDecimalStr","padStart","alignDecimal","decimalLength","str","concat","padEnd","clone","offset","maxDecimalLength","myAlignedDecimal","offsetAlignedDecimal","valueStr","_trimNumber","negativeStr","hydrateValueStr","slice","NaN","fullStr","getMiniDecimal","roundUpUnsignedDecimal","numStr","precision","_trimNumber2","integerStr","advancedDecimal","repeat","roundDownUnsignedDecimal","_trimNumber3","numberWithoutDecimal","separatorStr","_trimNumber4","precisionDecimalStr","advancedNum"],"sources":["E:/WeChat Files/wxid_77r24v1adq6c22/FileStorage/File/2024-11/前端代码/courseweb/course/node_modules/ant-design-vue/es/input-number/src/utils/MiniDecimal.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n/* eslint-disable max-classes-per-file */\nimport { getNumberPrecision, isE, num2str, trimNumber, validateNumber } from './numberUtil';\nimport { supportBigInt } from './supportUtil';\n/**\n * We can remove this when IE not support anymore\n */\nexport var NumberDecimal = /*#__PURE__*/function () {\n  function NumberDecimal(value) {\n    _classCallCheck(this, NumberDecimal);\n    _defineProperty(this, \"origin\", '');\n    if (!value && value !== 0 || !String(value).trim()) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    this.number = Number(value);\n  }\n  _createClass(NumberDecimal, [{\n    key: \"negate\",\n    value: function negate() {\n      return new NumberDecimal(-this.toNumber());\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new NumberDecimal(value);\n      }\n      var target = Number(value);\n      if (Number.isNaN(target)) {\n        return this;\n      }\n      var number = this.number + target;\n      // [Legacy] Back to safe integer\n      if (number > Number.MAX_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MAX_SAFE_INTEGER);\n      }\n      if (number < Number.MIN_SAFE_INTEGER) {\n        return new NumberDecimal(Number.MIN_SAFE_INTEGER);\n      }\n      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));\n      return new NumberDecimal(number.toFixed(maxPrecision));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return Number.isNaN(this.number);\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.number;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return num2str(this.number);\n    }\n  }]);\n  return NumberDecimal;\n}();\nexport var BigIntDecimal = /*#__PURE__*/function () {\n  function BigIntDecimal(value) {\n    _classCallCheck(this, BigIntDecimal);\n    _defineProperty(this, \"origin\", '');\n    if (!value && value !== 0 || !String(value).trim()) {\n      this.empty = true;\n      return;\n    }\n    this.origin = String(value);\n    // Act like Number convert\n    if (value === '-') {\n      this.nan = true;\n      return;\n    }\n    var mergedValue = value;\n    // We need convert back to Number since it require `toFixed` to handle this\n    if (isE(mergedValue)) {\n      mergedValue = Number(mergedValue);\n    }\n    mergedValue = typeof mergedValue === 'string' ? mergedValue : num2str(mergedValue);\n    if (validateNumber(mergedValue)) {\n      var trimRet = trimNumber(mergedValue);\n      this.negative = trimRet.negative;\n      var numbers = trimRet.trimStr.split('.');\n      this.integer = BigInt(numbers[0]);\n      var decimalStr = numbers[1] || '0';\n      this.decimal = BigInt(decimalStr);\n      this.decimalLen = decimalStr.length;\n    } else {\n      this.nan = true;\n    }\n  }\n  _createClass(BigIntDecimal, [{\n    key: \"getMark\",\n    value: function getMark() {\n      return this.negative ? '-' : '';\n    }\n  }, {\n    key: \"getIntegerStr\",\n    value: function getIntegerStr() {\n      return this.integer.toString();\n    }\n  }, {\n    key: \"getDecimalStr\",\n    value: function getDecimalStr() {\n      return this.decimal.toString().padStart(this.decimalLen, '0');\n    }\n    /**\n     * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000\n     * This is used for add function only.\n     */\n  }, {\n    key: \"alignDecimal\",\n    value: function alignDecimal(decimalLength) {\n      var str = \"\".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, '0'));\n      return BigInt(str);\n    }\n  }, {\n    key: \"negate\",\n    value: function negate() {\n      var clone = new BigIntDecimal(this.toString());\n      clone.negative = !clone.negative;\n      return clone;\n    }\n  }, {\n    key: \"add\",\n    value: function add(value) {\n      if (this.isInvalidate()) {\n        return new BigIntDecimal(value);\n      }\n      var offset = new BigIntDecimal(value);\n      if (offset.isInvalidate()) {\n        return this;\n      }\n      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset.getDecimalStr().length);\n      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);\n      var offsetAlignedDecimal = offset.alignDecimal(maxDecimalLength);\n      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();\n      // We need fill string length back to `maxDecimalLength` to avoid parser failed\n      var _trimNumber = trimNumber(valueStr),\n        negativeStr = _trimNumber.negativeStr,\n        trimStr = _trimNumber.trimStr;\n      var hydrateValueStr = \"\".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, '0'));\n      return new BigIntDecimal(\"\".concat(hydrateValueStr.slice(0, -maxDecimalLength), \".\").concat(hydrateValueStr.slice(-maxDecimalLength)));\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.empty;\n    }\n  }, {\n    key: \"isNaN\",\n    value: function isNaN() {\n      return this.nan;\n    }\n  }, {\n    key: \"isInvalidate\",\n    value: function isInvalidate() {\n      return this.isEmpty() || this.isNaN();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(target) {\n      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());\n    }\n  }, {\n    key: \"lessEquals\",\n    value: function lessEquals(target) {\n      return this.add(target.negate().toString()).toNumber() <= 0;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      if (this.isNaN()) {\n        return NaN;\n      }\n      return Number(this.toString());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var safe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (!safe) {\n        return this.origin;\n      }\n      if (this.isInvalidate()) {\n        return '';\n      }\n      return trimNumber(\"\".concat(this.getMark()).concat(this.getIntegerStr(), \".\").concat(this.getDecimalStr())).fullStr;\n    }\n  }]);\n  return BigIntDecimal;\n}();\nexport default function getMiniDecimal(value) {\n  // We use BigInt here.\n  // Will fallback to Number if not support.\n  if (supportBigInt()) {\n    return new BigIntDecimal(value);\n  }\n  return new NumberDecimal(value);\n}\n/**\n * round up an unsigned number str, like: 1.4 -> 2, 1.5 -> 2\n */\nexport function roundUpUnsignedDecimal(numStr, precision) {\n  var _trimNumber2 = trimNumber(numStr),\n    integerStr = _trimNumber2.integerStr,\n    decimalStr = _trimNumber2.decimalStr;\n  var advancedDecimal = getMiniDecimal(integerStr + '.' + decimalStr).add(\"0.\".concat('0'.repeat(precision), 5));\n  return toFixed(advancedDecimal.toString(), '.', precision);\n}\n/**\n * round up an unsigned number str, like: 1.4 -> 1, 1.5 -> 1\n */\nexport function roundDownUnsignedDecimal(numStr, precision) {\n  var _trimNumber3 = trimNumber(numStr),\n    negativeStr = _trimNumber3.negativeStr,\n    integerStr = _trimNumber3.integerStr,\n    decimalStr = _trimNumber3.decimalStr;\n  var numberWithoutDecimal = \"\".concat(negativeStr).concat(integerStr);\n  if (precision === 0) {\n    return integerStr;\n  }\n  return \"\".concat(numberWithoutDecimal, \".\").concat(decimalStr.padEnd(precision, '0').slice(0, precision));\n}\n/**\n * Align the logic of toFixed to around like 1.5 => 2\n */\nexport function toFixed(numStr, separatorStr, precision) {\n  if (numStr === '') {\n    return '';\n  }\n  var _trimNumber4 = trimNumber(numStr),\n    negativeStr = _trimNumber4.negativeStr,\n    integerStr = _trimNumber4.integerStr,\n    decimalStr = _trimNumber4.decimalStr;\n  var precisionDecimalStr = \"\".concat(separatorStr).concat(decimalStr);\n  var numberWithoutDecimal = \"\".concat(negativeStr).concat(integerStr);\n  if (precision >= 0) {\n    // We will get last + 1 number to check if need advanced number\n    var advancedNum = Number(decimalStr[precision]);\n    if (advancedNum >= 5) {\n      var advancedDecimal = getMiniDecimal(numStr).add(\"\".concat(negativeStr, \"0.\").concat('0'.repeat(precision)).concat(10 - advancedNum));\n      return toFixed(advancedDecimal.toString(), separatorStr, precision);\n    }\n    if (precision === 0) {\n      return numberWithoutDecimal;\n    }\n    return \"\".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, '0').slice(0, precision));\n  }\n  if (precisionDecimalStr === '.0') {\n    return numberWithoutDecimal;\n  }\n  return \"\".concat(numberWithoutDecimal).concat(precisionDecimalStr);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}